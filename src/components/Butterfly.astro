---
/**
 * Butterfly Effect Canvas - Interactive Lorentz Attractor Visualization
 *
 * Pure Astro component that renders an animated Lorentz attractor (butterfly effect)
 * using HTML5 Canvas. Features dark mode support, responsive sizing, and click-to-reset.
 *
 * The Lorentz system is a set of differential equations that exhibits chaotic behavior,
 * creating the characteristic "butterfly" pattern.
 *
 * @see https://en.wikipedia.org/wiki/Lorenz_system
 */
---

<canvas
    id="butterfly-canvas"
    class="mx-auto rounded-lg cursor-pointer"
    role="img"
    aria-label="Interactive Lorentz Attractor visualization. Click to reset the animation."
></canvas>

<script>
    // Lorentz Attractor Configuration
    // See: https://en.wikipedia.org/wiki/Lorenz_system
    const CONFIG = {
        // Particle system
        PARTICLE_COUNT_MOBILE: 100,
        PARTICLE_COUNT_DESKTOP: 300,
        MOBILE_BREAKPOINT: 481, // px

        // Canvas sizing (multipliers of viewport width)
        CANVAS_WIDTH_LARGE: 0.5, // > 1370px
        CANVAS_WIDTH_MEDIUM: 0.6, // > 720px
        CANVAS_WIDTH_SMALL: 0.9, // < 720px
        CANVAS_HEIGHT_RATIO: 0.6, // Height as ratio of width
        BREAKPOINT_LARGE: 1370, // px
        BREAKPOINT_MEDIUM: 720, // px

        // Coordinate scaling factors
        WIDTH_SCALE_FACTOR: 13.0 / 600.0,
        HEIGHT_SCALE_FACTOR: 7.0 / 400.0,

        // Particle color ranges (RGB)
        COLOR_R_MIN: 26,
        COLOR_R_MAX: 232,
        COLOR_G_MIN: 35,
        COLOR_G_MAX: 234,
        COLOR_B_MIN: 126,
        COLOR_B_MAX: 246,

        // Lorenz attractor parameters
        // https://en.wikipedia.org/wiki/Lorenz_system
        SIGMA: 10, // Prandtl number (convection rate)
        BETA: 8.0 / 2.5, // Geometric factor
        RHO: 28, // Rayleigh number (temperature difference)
        DELTA_T_INITIAL: 0.001, // Initial time step
        DELTA_T_MAX: 0.01, // Maximum time step
        DELTA_T_INCREMENT: 0.00001, // Time step increment

        // Animation parameters
        ALPHA_INITIAL: 100, // Initial fade opacity
        ALPHA_MIN: 10, // Minimum fade opacity
        ALPHA_DECREMENT: 0.2, // Fade rate
        LINE_WIDTH: 1.5, // Particle trail width

        // Background colors
        BG_LIGHT: 'rgb(255, 255, 255)',
        BG_DARK: 'rgb(40, 44, 52)', // #282c34 - One Dark theme

        // Particle initialization ranges
        PARTICLE_X_MIN: -100,
        PARTICLE_X_MAX: 100,
        PARTICLE_Y_MIN: -10,
        PARTICLE_Y_MAX: 10,
        PARTICLE_Z_MIN: -100,
        PARTICLE_Z_MAX: 100,
    } as const;

    /**
     * Manages the Butterfly animation including canvas setup, particle system,
     * rendering loop, and event handling.
     */
    class ButterflyAnimation {
        x: number;
        y: number;
        z: number;
        sigma: number;
        beta: number;
        rho: number;
        dt: number;

        constructor(x: number, y: number, z: number) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.sigma = CONFIG.SIGMA;
            this.beta = CONFIG.BETA;
            this.rho = CONFIG.RHO;
            this.dt = CONFIG.DELTA_T_INITIAL;
        }

        /**
         * Generate random integer in range [min, max] inclusive
         */
        randInt(min: number, max: number): number {
            return Math.floor(Math.random() * (max - min + 1) + min);
        }

        /**
         * Randomize particle position within configured bounds
         */
        randomize(): void {
            this.x = this.randInt(CONFIG.PARTICLE_X_MIN, CONFIG.PARTICLE_X_MAX);
            this.y = this.randInt(CONFIG.PARTICLE_Y_MIN, CONFIG.PARTICLE_Y_MAX);
            this.z = this.randInt(CONFIG.PARTICLE_Z_MIN, CONFIG.PARTICLE_Z_MAX);
            this.dt = CONFIG.DELTA_T_INITIAL;
        }

        /**
         * Update particle position using Lorenz attractor differential equations.
         *
         * The equations are:
         * - dx/dt = σ(y - x)
         * - dy/dt = x(ρ - z) - y
         * - dz/dt = xy - βz
         *
         * Time step gradually increases to create expanding pattern.
         */
        update(): void {
            this.x += this.sigma * (this.y - this.x) * this.dt;
            this.y += (this.x * (this.rho - this.z) - this.y) * this.dt;
            this.z += (this.x * this.y - this.beta * this.z) * this.dt;
            if (this.dt < CONFIG.DELTA_T_MAX) this.dt += CONFIG.DELTA_T_INCREMENT;
        }

        /**
         * Create a copy of this particle at its current position
         */
        copy(): ButterflyAnimation {
            return new ButterflyAnimation(this.x, this.y, this.z);
        }
    }

    /**
     * Generate random integer in range [min, max] inclusive
     */
    const rand = (min: number, max: number): number =>
        Math.floor(Math.random() * (max - min + 1) + min);

    /**
     * Animation manager for the Lorentz Attractor visualization.
     * Manages canvas, particle system, rendering loop, and event handling.
     */
    class LorentzParticle {
        canvas: HTMLCanvasElement;
        ctx: CanvasRenderingContext2D;
        particles: ButterflyAnimation[] = [];
        colors: string[] = [];
        animationId: number | null = null;
        alpha: number = 100;
        isDark: boolean = false;

        constructor(canvas: HTMLCanvasElement) {
            this.canvas = canvas;
            this.ctx = canvas.getContext('2d')!;
            this.isDark = document.documentElement.classList.contains('dark');
            this.init();
            this.setupEventListeners();
        }

        /**
         * Calculate number of particles based on viewport width.
         * Fewer particles on mobile for better performance.
         */
        getNumberOfParticles(): number {
            return window.innerWidth < CONFIG.MOBILE_BREAKPOINT
                ? CONFIG.PARTICLE_COUNT_MOBILE
                : CONFIG.PARTICLE_COUNT_DESKTOP;
        }

        /**
         * Calculate canvas width based on viewport width.
         * Responsive sizing: 50% on large screens, 60% on medium, 90% on small.
         */
        getWidth(): number {
            const width = window.innerWidth;
            if (width > CONFIG.BREAKPOINT_LARGE) return width * CONFIG.CANVAS_WIDTH_LARGE;
            if (width > CONFIG.BREAKPOINT_MEDIUM) return width * CONFIG.CANVAS_WIDTH_MEDIUM;
            return width * CONFIG.CANVAS_WIDTH_SMALL;
        }

        /**
         * Calculate canvas height maintaining aspect ratio
         */
        getHeight(): number {
            const width = this.getWidth();
            return width * CONFIG.CANVAS_HEIGHT_RATIO;
        }

        /**
         * Calculate scaling factor for X coordinate mapping
         */
        getWidthScaler(canvasWidth: number): number {
            return CONFIG.WIDTH_SCALE_FACTOR * canvasWidth;
        }

        /**
         * Calculate scaling factor for Z coordinate mapping
         */
        getHeightScaler(canvasHeight: number): number {
            return CONFIG.HEIGHT_SCALE_FACTOR * canvasHeight;
        }

        /**
         * Initialize particle system with random positions and colors
         */
        initialize(): void {
            const nParticles = this.getNumberOfParticles();
            this.particles = [];
            this.colors = [];

            for (let i = 0; i < nParticles; i++) {
                const p = new ButterflyAnimation(0, 0, 0);
                p.randomize();
                this.particles.push(p);
                this.colors.push(
                    `rgb(${rand(CONFIG.COLOR_R_MIN, CONFIG.COLOR_R_MAX)}, ${rand(CONFIG.COLOR_G_MIN, CONFIG.COLOR_G_MAX)}, ${rand(CONFIG.COLOR_B_MIN, CONFIG.COLOR_B_MAX)})`,
                );
            }

            const canvasWidth = this.canvas.width;
            const canvasHeight = this.canvas.height;
            this.ctx.fillStyle = this.isDark ? CONFIG.BG_DARK : CONFIG.BG_LIGHT;
            this.ctx.fillRect(0, 0, canvasWidth, canvasHeight);
        }

        /**
         * Initialize canvas and start animation
         */
        init(): void {
            const canvasWidth = this.getWidth();
            const canvasHeight = this.getHeight();

            this.canvas.width = canvasWidth;
            this.canvas.height = canvasHeight;
            this.alpha = CONFIG.ALPHA_INITIAL;

            this.initialize();
            this.animate();
        }

        /**
         * Main animation loop - updates and renders all particles
         */
        animate(): void {
            const nParticles = this.getNumberOfParticles();
            const widthScaler = this.getWidthScaler(this.canvas.width);
            const heightScaler = this.getHeightScaler(this.canvas.height);

            const draw = () => {
                if (this.alpha > CONFIG.ALPHA_MIN) this.alpha -= CONFIG.ALPHA_DECREMENT;

                this.ctx.fillStyle = this.isDark
                    ? `rgba(40, 44, 52, ${this.alpha / 100})`
                    : `rgba(255, 255, 255, ${this.alpha / 100})`;

                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                this.ctx.save();
                this.ctx.translate(this.canvas.width / 2, 0);

                for (let i = 0; i < nParticles; i++) {
                    const oldP = this.particles[i].copy();
                    this.particles[i].update();
                    const newP = this.particles[i].copy();

                    this.ctx.strokeStyle = this.colors[i];
                    this.ctx.lineWidth = CONFIG.LINE_WIDTH;
                    this.ctx.beginPath();
                    this.ctx.moveTo(
                        oldP.x * widthScaler,
                        this.canvas.height - oldP.z * heightScaler,
                    );
                    this.ctx.lineTo(
                        newP.x * widthScaler,
                        this.canvas.height - newP.z * heightScaler,
                    );
                    this.ctx.stroke();
                }

                this.ctx.restore();
                this.animationId = requestAnimationFrame(draw);
            };

            draw();
        }

        /**
         * Reset animation by reinitializing particles (triggered by canvas click)
         */
        reset(): void {
            this.alpha = CONFIG.ALPHA_INITIAL;
            this.initialize();
        }

        /**
         * Update background colors when theme changes
         */
        updateTheme(): void {
            this.isDark = document.documentElement.classList.contains('dark');
            this.reset();
        }

        /**
         * Set up event listeners for user interaction and theme changes
         */
        setupEventListeners(): void {
            this.canvas.addEventListener('click', () => this.reset());
            window.addEventListener('themechange', () => this.updateTheme());
        }

        /**
         * Clean up animation frame on component destruction
         */
        destroy(): void {
            if (this.animationId) {
                cancelAnimationFrame(this.animationId);
            }
        }
    }

    // Initialize when DOM is ready
    document.addEventListener('DOMContentLoaded', () => {
        const canvas = document.getElementById(
            'butterfly-canvas',
        ) as HTMLCanvasElement;
        if (canvas) {
            new LorentzParticle(canvas);
        }
    });
</script>

<style>
    #butterfly-canvas {
        display: block;
    }
</style>
